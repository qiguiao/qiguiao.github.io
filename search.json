[{"title":"JavaScript24道经典算法","url":"/2018/07/24/JavaScript24道经典算法/","content":"\n前言\n\n 身为前端，没点干货分享哪行，搞一搞经典算法，一个JS的起点，一个热爱与奋斗的理由，\n 开搞~~~~~~\n\n ```\n\n\t//1、标准排序\n\tvar arr = [5,8,3,6,9]\n\tfor(var i=0;i<arr.length;i++){\n\t\tfor(var j=i+1;j<arr.length;j++){\n\t\t \tvar temp\n\t\t \tif(arr[i]>arr[j]){\n\t\t \t \ttemp=arr[i];\n\t\t \t \tarr[i]=arr[j];\n\t\t \t \tarr[j]=temp;\n\t\t\t}\n\n\t\t}\n\t}\n\t console.log(arr)\n\t //第二种：冒泡排序\n\tvar arr = [5,4,6,1,3,2];\n\t\n\tfor(var i=0;i<arr.length;i++){\n\t\tfor(var j=0;j<arr.length-i+1;j++){\n\t\t\tvar temp;\n\t\t\tif(arr[j]>arr[j+1]){\n\t\t\t\ttemp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\t \n\t\t\t\n\n\t //2、字符串出现最多个数（2种）\n\t //.str=”abcdefgaaass”找字符中出现最多的;第一种\n\t \tvar str ='abcdefgaaass'\n          var newarr=str.split(\"\");\n          var max=0,val=\"\";\n          function fn(arr,a){\n            var count=0;\n            for(var i=0;i<arr.length;i++){\n                if(arr[i]==a){\n                  count++;\n                }\n            }\n            return count;\n          }\n          for(var i=0;i<newarr.length;i++){\n              var ind=fn(newarr,newarr[i]);\n              if(ind>max){\n                max=ind;\n                val=newarr[i];\n              }\n          }\n          console.log(\"出现最多的字符是\"+val+\"出现的次数是\"+max)\n          //第二种\n          var strr='aaasssssbbbcccccccccccccccccccccc'\n          function change(arr){\n          \tfor(var j=0,len=0,str1='';j<arr.length;j++){\n          \tvar x = arr.substr(j,1);\n          \tvar y = arr.split(x);\n          \tif(y.length-1>len){\n          \t\tlen = y.length-1;\n          \t\tstr1=x+','+len;\n\n          \t}\n          }\n\t\t\t\treturn str1;\n          }\n          \n          console.log(change(strr));\n\n\t\t\n\t\t//3、编程实现，往数组里插入一个元素\n\t\tvar arr = [\"1411A\",\"44\",\"34305\",\"djg\",\"pic\"];\n\t\tfunction fun3(ar,index,date){\n\t\t\tfor(var i=ar.length-1;i>=index;i--){\n\t\t\t\tar[i+1]=ar[i];\n\t\t\t}\n\t\t\tar[index] = date;\n\t\t}\n\t\tfun3(arr,2,\"hello\");\n\t\tconsole.log(arr);\n\n\n\t\t//4、编程实现IndexOf方法\n\t\tvar brr=[5,9,6,3,2,5];\n\t\tfunction indexfun(arr,val){\n\t\t\tfor(var i=0;i<arr.length;i++){\n\t\t\t\tif(arr[i]===val){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tconsole.log(indexfun(brr,13));\n\n\n\t\t//5、求数组中最大值和最小值\n\t\tvar arr=[2,41,3,1,8];\n\t\tvar  temp=arr[0];\n\n\t\t for(var i=0;i<arr.length;i++){\n\t\t \t  if(arr[i]<temp){\n\t\t \t  \ttemp=arr[i];\n\t\t \t  }\n\t\t }\n\t\t console.log(temp)\n\n\t\t // 6、将字符串转换为驼峰形式\n        var  str=\"border-bottom-color\";\n        function isstr(str){\n          var arr=str.split(\"-\");\n          var one=arr[0];\n          for(var i=1;i<arr.length;i++){\n              one+=arr[i].charAt(0).toUpperCase()+arr[i].substring(1);\n          }\n          return one;\n        }\n        console.log(isstr(str));\n        //7、var  str='a2b4admin3'字符的每个数字都乘2 ,成为'a4b8admin6'\n\t   var url='a2b4admin3';\n\t   var str11=''\n\t    for(var i=0;i<url.length;i++){\n\t    \t  if(!isNaN(url[i])){\n\t    \t  \tstr11=str11+url[i]*2\n\t    \t  }else{\n\t    \t  \tstr11=str11+url[i]\n\t    \t  }\n\t    }\n\t    console.log(str11)\n\n\t    //8、var  str='a2b4admin3'将字符串中的数字用中括号括起来 'a[2]b[4]admin[3]'\n\t  function  num(str){\n\t  var  arr=str.split('')\n\t  for(var i=0;i<arr.length;i++){\n\t          if(!isNaN(arr[i])){\n\t          \tarr[i]=\"[\"+arr[i]+\"]\"\n\t          }\n\n\t  }\n\t \treturn arr.join('')\n\t  }\n\n\t console.log(num(url))\n\t //9、首先判断在数组中哪个数最大，然后让数组中的第一个数与最大的数相乘，返回结果\n\t\t function maxn(arr){\n\t\t\t\tvar big=arr[0];\n\t\t\t\tfor(var i=0;i<arr.length;i++){\n\t\t\t\t\tif(arr[i]>big){\n\t\t\t\t\t\tbig=arr[i]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn big*arr[0]\n\t\t\t}\n\t\t\tconsole.log(maxn([2,1,80,6,10]));\n\n\t//10、 var str='abc' 让字符串重复3遍，成为 str='abcabcabc'\n\tvar str='abc';\n\t\tfunction xun(a,b){\n\t\t\tvar newstr='';\n\t\t\tfor(var i=1;i<=b;i++){\n\t\t\t\tnewstr+=a\n\t\t\t}\n\t\t\treturn newstr\n\t\t}\n\t\tconsole.log(xun(str,3));\n\n\t\t\n\t\t//11、10到100的十位随机数并排序\n\t\tfor(var i=1;i<=10;i++){\t\t\t\n\t\t\t\tvar ran=Math.floor(Math.random()*91+10)\t\t\t\n\t\t\tarr.push(ran)\n\t\t}\n\t\tconsole.log(arr.sort(function(a,b){return a-b}))\n\n\t\t//12、写出一个段脚本，输出当前日期5天之后是星期几,三种方法\n\t\t//第一种\n\t\t/*var now=new Date();\n\t\tvar day=now.getDate()\n\t\tvar week=['日','一','二','三','四','五','六']\n\t\tnow.setDate(day+5)\n\t\tconsole.log('星期'+week[now.getDay()])*/\n\t\t//第二种\n\t\t/*var now=new Date();\n\t\tvar year=now.getFullYear();\n\t\tvar month=now.getMonth();\n\t\tvar date=now.getDate();\n\t\tvar week=['日','一','二','三','四','五','六']\n\t\tvar fulture=new Date(year,month,date+5);\n\t\tconsole.log('5天之后是星期'+week[fulture.getDay()])*/\n\t\t//第三种\n\t\t/*var now=new Date();\n\t\tvar time=now.getTime();\n\t\tvar fulture=new Date();\t\t\n\t\tvar ftime=time+24*60*60*1000*5;\n\t\tvar week=['日','一','二','三','四','五','六'];\t\n\t\t\tfulture.setTime(ftime);\n\t\tconsole.log('5天之后是星期'+week[fulture.getDay()])*/\n\n\t\t//13、封装一个n天之后是星期几的函数\n\t\tfunction getday(n){\n\t\t\tn=typeof(n)==='undefined'?0:n;\n\t\t\tvar now=new Date();\n\t\t\tvar time=now.getTime();\n\t\t\tvar fulture=new Date();\n\t\t\tvar ftime=time+24*60*60*1000*n;\n\t\t\tfulture.setTime(ftime);\n\t\t\treturn fulture.getDay();\n\t\t}\n\t\tconsole.log(getday());\n\n\t\t//14、\"wellcome  to beijing\"把第一个变大写返回'WellcomeToBeijing'\n\t\t//和上题相同。驼峰\n\t\t\n\n\t\t//15、封装一个方法，实现求任意多个数的平均值。\n\t\tfunction f1(){\n\t\t\t//用一个变量接收和\n\t\t\tvar temp = 0;\n\t\t\t//循环每个参数\n\t\t\tfor(var i=0; i<arguments.length; i++){\n\t\t\t\ttemp += arguments[i];\n\t\t\t}\n\t\t\t//返回平均数\n\t\t\treturn temp/arguments.length;\n\t\t}\n\t\tconsole.log(f1(1,2,3,4,9))\n\n\t\t//16、/*判断字符串是否对称*/\n\t\tvar  str1=\"abch6g5g6hcba\";      // aba\n        function isduic(str){\n            for(var i=0,len=str1.length;i<len/2;i++){\n              // alert(str[i]);\n              if(str[i]!=str[len-1-i]){//str.charAt(i)!=str.charAt(len-1-i);\n                  return \"不对称\";\n              }\n            }\n            return \"对称\";\n        }\n        console.log(isduic(str1));\n\n        //17、千分符\n         var str2=46548978911;\n        function qianff(str){\n            var strn=str.toString(),\n                len=strn.length,\n                ind=len%3,\n                //console.log(strn);\n                newstr=strn.substr(0,ind);\n                console.log(newstr);\n                if(ind==0){\n                   newstr=strn.substr(0,3);\n                    ind=3;\n                    //console.log(newstr);\n                }\n                for(i=ind;i<len;i=i+3){\n                  newstr+=\",\"+strn.substr(i,3);\n                }\n                return newstr;\n        }\n        console.log(qianff(str2))\n\n        //18、随机生成十六进制的颜色值 var arr=[\"0\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\"]\n        var arrHex=[\"0\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\"];\n\t\tvar fuhao = \"#\";\n\t\tfor(var i=0;i<6;i++){\n\t\t\tvar color = arrHex[Math.floor(Math.random()*arrHex.length)];\n\t\t\tfuhao= fuhao+color;\n\t\t\t// str =str+arrHex[a];\n\t\t}\n\t\tconsole.log(fuhao);\n\n\t\t//19、随机从数组中取出三个不同的值。var arr = [1,2,3,4,5,6,7,8,9];\n\t\tvar arr = [1,2,3,4,5,6,7,8,9];\n\t\tvar brr = [];\n\t\tfor(var i=0;brr.length<3;i++){\n\t\t\tvar a = Math.floor(Math.random()*arr.length);\n\t\t\tvar b = arr[a];\n\t\t\tif(brr.indexOf(b)==-1){\n\t\t\t\tbrr.push(b);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tconsole.log(brr);\n\n\t\t//20、求数组中字符串的个数\n\t\tvar str=[0,1,2,3,4,5,\"a\",\"b\",\"c\",\"b\"],sum=0;\n\t\tfunction strn(arr){\n\t\t\tfor(var i=0;i<arr.length;i++){\n\t\t\t\tif(typeof(arr[i])==\"string\"){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tconsole.log(strn(str));\n\n\t\t//21、删除数组中指定的值\n\t\tvar drr = [\"1411A\",\"44\",\"34305\",\"djg\",\"pic\",100,35,28];\n\t\tfunction fun5(rr,num){\n\t\t\t// for(var i = 0; i<rr.length;i++){\n\t\t\t// \tif(rr[i]==num){\n\t\t\t// \t\trr.splice(i,1);\n\t\t\t// \t\tbreak;\n\t\t\t// \t}\n\t\t\t// }\n\t\t\tvar newrr = rr.splice(num,1);\n\t\t\treturn rr;\t\t\t\n\t\t}\n\t\tconsole.log(fun5(drr,1));\n\n\t\t//22、把重复的值放入一个新的数组中  //这中方法过于繁琐，可以使用indexOf方法，等于-1判断\n\t\tvar hrr = [\"55\",\"55\",\"2\",\"1\"];\n\t\tfunction fun7(rra,num){\n\t\t\tvar a = 0;\n\t\t\tfor(var i = 0;i<rra.length;i++){\n\t\t\t\tif(rra[i]==num){\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tvar rrb = [];\n\t\tfor(var i = 0 ;i <hrr.length;i++){\n\t\t\tvar length = fun7(hrr,hrr[i]);\n\t\t\tif(length >1){\n\t\t\t\trrb.push(hrr[i]);\n\t\t\t}\n\t\t}\n\t\tconsole.log(rrb);\n\n\t\t//23、截取字符串的var s=\"abcdefg\";截取完成后实现反转功能：g,f,e  其实等同于数组翻转\n\t\t\t// 第一种\n\t\t/*var str=\"hello\";\n\t\tvar arr=str.split(\"\");\n\t\tvar rts=arr.reverse();\n\t\tconsole.log(rts);*/\n\t\t// 第二种\n\t\t/*var str=\"hello\";\n\t\tvar strn=\"\";\n\t\tfor(var i=str.length;i>=0;i--){\n\t\t\tstrn+=str[i];\n\t\t}\n\t\tconsole.log(strn);*/\n\t\t//第三种\n\t\t/*var str=\"hello\",arr=[];\n\t\tfor(var i=0;i<str.length;i++){\n\t\t\tarr.unshift(str[i]);\n\t\t}\n\t\tconsole.log(arr);*/\n\n\t\t//24、拓展一个方法，用于删除数组中的指定值。同21题一样\n\n\n\t\t//附1：编程实现数组中有几个字符串元素\n\t\tvar brr = [\"1411A\",\"44\",\"34305\",\"djg\",\"pic\",100,35,28];\n\t\tfunction fun4(crr){\n\t\t\tvar count = 0;\n\t\t\tfor(var i = 0;i<crr.length;i++){\n\t\t\t\tif(typeof crr[i] == \"string\"){\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tfun4(brr);\n\t\t\n\t\t\n\t\t//附2：数组反转\n\t\tvar s = \"abcdefghiklmn\";\n\t\tfunction fun6(str){\n\t\t\t// var ss = s.splice(\"\");\n\t\t\tvar ss = s.split(\"\");\n\t\t\tvar ssa = [];\n\t\t\tfor(var i = 0 ;i<ss.length;i++){\n\t\t\t\tssa.unshift(ss[i]);\n\t\t\t}\n\t\t\treturn ssa.join(\"\");\n\t\t}\n\t\tfun6(s);\n\t\t//附3：将所有数组内所有重复的值取出来放到一个新的数组中\n\t  // var st=\"123abcdefgaaaasssssssssssssss123\",srn=\"\",cou=0;\n\t  // var str=st.split(\"\");\n\t  // function stn(srr,strn){\n\t  // \tvar count=0;\n\t  // \tfor(var i=0;i<srr.length;i++){\t\n\t  // \t\tif(srr[i]==strn){\n\t  // \t\t\tcount++;\n\t  // \t\t}\n\t  // \t}\n\t  // \treturn count;\n\t  // }            \n\t  // for(var i=0;i<str.length;i++){\n\t  // \tvar anr=stn(str,str[i]);\n\t  // \tif(anr>cou){\n\t  // \t\tcou=anr;\n\t  // \t\tsrn=str[i];\n\t  // \t}\n\t  // }  \n\t  // console.log(\"出现最多的字母是\"+srn+\"次数\"+cou); \n\n```\n\n说明\n算法是帮助前端开拓思路的最好方法，希望可以帮助到你。"},{"title":"微信小程序Template模板","url":"/2018/07/24/微信小程序Template模板/","content":"\n前言：\n \n 好久没有 嘚嘚嘚嘚嘚 了,最近忙于开发React，独立开发属实有点疲惫一直未更新博客，\n 希望以后能够持续输出，为前端圈子贡献一份美好，今天给大家 Say Say 一下小程序中\n 的Template。\n\n\n 1. template意思在于一个页面划分为多个模块 控制显示与隐藏。\n\n 2. 在pages/页面名称/页面名称  下创建components文件夹(与小程序的组件是两回事)\n\n 3. 在刚才创建的文件夹下创建 Message.wxml (名称可以自定义，我需要一个消息模板，所以创建了Message.wxml)\n\n ```\n   template上的 “name” 是重点，一定要想好名称\n\n    <template name=\"NoMessage\">\n        <view class=\"no-msg\">\n\n        </view>\n\n    </template>\n\n```\n\n4. 调用(例：pages/message/message.wxml 上调用)\n\n ```\n   这个import 是引用的文件\n\n   <import src=\"./components/NoMessage.wxml\"/>\n\n   书写template \"is\" 上写 刚才起的name名称  wx:if用来判断是否显示\n\n   <template is=\"NoMessage\" wx:if=\"{{NoMessage}}\"></template>\n\n```\n\n\n说明\n\n在template中的 图片路径跟 页面上书写时一置(无需考虑多了一层 多加一个../)\n\n如果控制台报错 webview网络渲染层错误，说明你的图片路径有误，不是多写了就是少写了层级\n\n多个template可以将一个页面划分为多个模块，但是需要注意 同时只能存在一个true，不然就会出现两个页面了\n\n前端@Jaket_7O 有问题可以在掘金上滴滴我，希望可以帮助奋斗路上的你。"},{"title":"微信小程序封装组件与引用","url":"/2018/07/23/微信小程序封装组件与引用/","content":"\n1. 在与 pages 同级目录创建 components文件夹 \n\n2. 在components 下 创建一个文件夹(要创建的组件的名称)\n\n3. 在 2 的文件夹上右键 新建->Components (这时会出现一套文件 .js .json .wxml .wxss)\n\n4. 正常写HTML 和 css一样去书写代码 ， 在刚刚生成的.json中 书写\n\n```\n{\n  \"component\": true,\n  \"usingComponents\": {}\n}\n\n```\n\n5. 在刚刚生成的.js文件中 要抛出方法(抛出方法的前提是 你需要在wxml上绑定方法)\n\n```\n    绑定方法 wxml\n\n    <view class='modal-btn-cancel' bindtap='cancelEvent'>取消</view>\n    <view class='modal-btn-sure' bindtap=\"loginOutEvent\">退出登录</view>\n\n    抛出 js\n\n    /**\n   * 组件的方法列表\n   */\n  methods: {\n    toastShow(str){\n      var _this = this;\n      _this.setData({\n        isShow:true\n      })\n    },\n    toastHide(str) {\n      var _this = this;\n      _this.setData({\n        isShow: false\n      })\n    },\n    cancelEvent(){\n      this.triggerEvent(\"cancelEvent\")     //!!!!!!这是重点\n    },\n    loginOutEvent(){\n      this.triggerEvent(\"loginOutEvent\")    //!!!!!!这是重点\n    }\n  }\n\n```\n\n\n6. 调用你写的组件(找到需要用组件的页面的 .json 例：我需要在 “我的页面”中用到组件  在pages/mine/mine.json)\n\n```\n书写一下代码\n\n{\n  \"navigationBarTitleText\": \"我的\",\n  \"usingComponents\": {\n    \"new-modal\":\"/components/new-model/new-model\"\n  }\n}\n\n```\n\n7. 在对应页面上调用(pages/mine/mine.wxml)\n\n```\n书写一下代码(你会发现这个组件的名称是你在json中的 那个名称  Yes)\n\n<new-modal class=\"modal-modal\" bind:cancelEvent=\"cancelEventssss\" bind:loginOutEvent=\"loginOutEventssss\"></new-modal>\n\n```\n\n8. 在对应的js中调用(pages/mine/mine.js)\n\n```\n   /**\n   * 生命周期函数--监听页面加载\n   */\n\n   需要在生命周期中绑定一下\n\n  onLoad: function (options) {\n\n    this.modal = this.selectComponent('.modal-modal');\n\n  }\n\n  Event（事件中调用）\n\n  cancelEventssss:function(){\n    this.modal.toastHide()\n  },\n   loginOutEventssss:function(){\n    this.modal.toastHide()\n  },\n\n```\n\n\n说明\n\n小程序组件的用途在于 一次封装多次调用，减少copy时间\n\n希望能够帮助到正在奋斗路上的你"},{"title":"Charles抓包教程","url":"/2018/07/23/Charles抓包教程/","content":"\n    (下载抓包工具 ↓↓↓↓↓)\n\n- [点我下载抓包工具](http://xclient.info/s/6/?t=58c9317566d718aa421993eddfe2c9ae9d378d0c)\n\n\n\n1. 手动安装 一路next\n\n2. 手机\bwifi和电脑wifi必须一致。\n\n3. 打开电脑wifi查看其ip地址（mac为 打开网络偏好设置， Windows自行查找）。\n\n4. 打开手机wifi修改代理  \n\n    显示高级选项\n\n    服务器主机名  为 wifi ip地址\n\n    服务器端口号 8888\n\n    保存\n\n5. 打开charles工具 \n\n   黄色小刷子 代表清空 \n\n   红色按钮代表 开始 暂停 \n\n6. 点开将要抓包的应用 即可看到发出的请求\n\n7. \b\b可以起飞了。\n\n"},{"title":"微信小程序封装wx.request()请求","url":"/2018/04/28/微信小程序封装request/","content":"先封装common方便域名更改\n\n```\nmodule.exports = {\n  requestPath: \"https:\",   //开发 ， 测试 ，生产 ，域名都可以\n  apisPath: \"https:\",\n  ossImgPath: \"http:\"\n};\n\n```\n\n封装server.js\n\n```\nvar config = require('../common/config.js');\nmodule.exports = {\n  request: function (params) {\n    var signinStorage = wx.getStorageSync('signinStorage') || {};\n    var url = (params.apis ? config.apisPath : config.requestPath) + params.url;\n    return new Promise((resolve, reject) => {\n      wx.request({\n        url: url, //仅为示例，并非真实的接口地址\n        data: params.data || {},\n        method: params.method || 'GET',\n        header: {\n          'content-type': 'application/json',\n          // 'X-ECAPI-Authorization':\"bearer \"+signinStorage.token || '',\n          'Authorization': \"bearer \" + signinStorage.token || ''\n          \n        },\n        success: function (res) {\n          if (res.data.error_code == 10001) {\n            var pages = getCurrentPages();\n            var currentPages = pages[pages.length - 1];\n            var path = currentPages.route.replace('pages/', '../');\n            var opt = '';\n            if (currentPages.options) {\n              for (var k in currentPages.options) {\n                opt += '_a_' + k + '_e_' + currentPages.options[k];\n              }\n            }\n            // _a_  &\n            // _e_  =\n            // _q_  ?\n            if (opt) {\n              opt = opt.replace('_a_', '')\n              path += '_q_' + opt;\n            }\n            // wx.redirectTo({\n            //   url:'../login/login?done='+path\n            // })\n            wx.navigateTo({\n              url: '../login/login?done=' + path\n            })\n            return;\n          } else {\n            resolve(res.data)\n          }\n\n        }\n      })\n    })\n  },\n  mobileTest: /^1\\d{10}$/,\n  changeConsignee: function () { }\n}\n\n```\n\n调用 \n\n```\nvar services = require('../services/services.js');\n\nservices.request({\n      url:'api/aa/aa',   //api\n      method:'POST',     //请求方式\n      data:{\n        page: this.data.page   //传入参数\n      },\n    }).then((data)=>{\n      \n      // 返回值\n      \n    })\n\n```\n\n说明\n\n利用Promise封装请求\b,引入地址方便\b更换。\n\n调用方式简单，无需过多操作。"},{"title":"React封装Picker，适用于Mobile","url":"/2018/04/28/React封装Picker/","content":"```\nimport React from 'react';\nimport { Picker } from 'antd-mobile';\nexport default class DatePicker extends React.Component {\n  state={\n    data:[]\n  }\n\n  componentDidMount(){\n    let { value } = this.props;\n    if(value) this.setState({value});\n    this.init()\n  }\n  init=()=>{\n    //当前年月日\n    let date = new Date(), data=[];\n    let year = date.getFullYear();\n    let month = date.getMonth() + 1;\n    let day = date.getDate();\n    // 放入一个数组\n     let value = [year,month,day,1];\n    //  获取年月\n    for(let i=year-1;i<=year+1;i++){\n      let year_data = {label:i,value:i,children:[]};\n      for(let j=1;j<=12;j++){\n        year_data.children.push({label:j,value:j});\n      }\n      // 装入数组\n      data.push(year_data);\n    }\n    // 调用方法\n    let datas = this.get_days(data, value);\n    this.setState({data:datas.data,value:datas.value});\n  }\n  get_days=(data=[],value=[])=>{\n    let f_index = -1, s_index = value[1]-1;\n    data.map((e, i)=>{\n      if(e.value===value[0]) f_index = i;\n      return e;\n    });\n    if(value[0] && value[1]){\n      if(!data[f_index].children[s_index].children){\n        let len = new Date(value[0], value[1], 0).getDate();\n        data[f_index].children[s_index].children=[];\n        for(let i=1;i<=len;i++){\n          data[f_index].children[s_index].children.push({\n            label:i,\n            value:i,\n            children:[{\n              label: '00:00-12:00',\n              value: '00:00-12:00',\n            },\n            {\n              label: '12:00-17:00',\n              value: '12:00-17:00',\n            },\n            {\n              label: '17:00-24:00',\n              value: '17:00-24:00',\n            }]\n          });\n        }\n      }\n    }\n    return {data,value, cur_month_days:data[f_index].children[s_index].children}\n  }\n  onPickerChange=(v)=>{\n    let { value, data } = this.state;\n    if(value[0]!==v[0]||value[1]!==v[1]){\n      if(value[0]!==v[0]) v[1] = value[1];\n      let datas = this.get_days(data, v);\n      if(value[2]) v[2]=datas.cur_month_days[value[2]-1]?value[2]:datas.cur_month_days[datas.cur_month_days.length-1].value;\n      if(!v[2]) v[2]=1;\n      v[3]=value[3]||1;\n      this.setState({\n        data:datas.data,\n        value:v\n      })\n    }else {\n      if(v[2]!==value[2]) v[3] = value[3];\n      this.setState({\n        value:v\n      })\n    }\n  }\n  render() {\n    let { data } = this.state, { children, onOk } = this.props;\n    return(\n      <Picker\n        data={data}\n        cols={4}\n        title=\"Calendar\"\n        cascade={true}\n        extra=\"请选择(可选)\"\n        okText=\"Done\"\n        dismissText=\"Close\"\n        value={this.state.value}\n        onPickerChange={this.onPickerChange}\n        onOk={v =>  onOk(v)}\n        className=\"date_picker\"\n      >\n        {children}\n      </Picker>\n    )\n  }\n}\n\n```\n调用\n\n```\nimport DatePicker from 'component/DatePicker';\n<DatePicker onOk={(v) => console.log(v)}></DatePicker>\nconsole.log(v) v是 年 月 日 时\n```\n\n说明\n\n\b适用于ReactMobile，选取时间。\n\n如果要进行时间加减换算，需注意，安卓和ios有兼容问题,\n\n安卓可识别2018-04-29 和 2018/04/29,\n\nios识别 2018/04/29,\n\n根据情况可采取 v.replace(/-/g,\"/\");\n\n"},{"title":"React封装Icon","url":"/2018/04/28/React封装Icon/","content":"\n```\nimport React from 'react';\nimport { Icon } from 'antd-mobile';\nexport default class RIcon  extends React.Component {\n  render(){\n    let props = this.props;\n    let isIconfont = /^ifont-/.test(props.type);\n    const iconComponent = isIconfont?(\n      <i className={`ifont ${props.type} ${props.spin?'anticon-spin':''}  ${props.className}`} onClick={props.onClick} style={{...props.style, fontSize: `${props.size || 14}px`, color: props.color }}></i>\n    ):(\n    <Icon title={props.title||''} type={props.type} spin={props.spin} onClick={props.onClick} className={props.className} style={{...props.style, fontSize: `${props.size || 14}px`, color: props.color}} />\n    )\n    return(\n      iconComponent\n    )\n  }\n}\n\n````\n\n```\n调用\n\nimport Icon  from '../../componen/Icon';\n<Icon tyep=”home“/>\n\n```\n说明 \n\n适用于 reactMobile，在antdMobile原有基础改善。\n\n修改为引入为 antd 也可适用于 PC。\n\n封装icon组件，方便调用 只需<Icon tyep=”home“/>即可调用。"},{"title":"HTML问题综述","url":"/2018/04/28/HTTP，HTML问题综述/","content":"#### HTTP状态码及其含义\n\n•\t1XX：信息状态码 \n\no\t100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\n•\t2XX：成功状态码 \n\no\t200 OK 正常返回信息\n\no\t201 Created 请求成功并且服务器创建了新的资源\n\no\t202 Accepted 服务器已接受请求，但尚未处理\n\n•\t3XX：重定向 \n\no\t301 Moved Permanently 请求的网页已永久移动到新位置。\n\no\t302 Found 临时性重定向。\n\no\t303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。\n\no\t304 Not Modified 自从上次请求后，请求的网页未修改过。\n\n•\t4XX：客户端错误 \n\no\t400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n\no\t401 Unauthorized 请求未授权。\n\no\t403 Forbidden 禁止访问。\n\no\t404 Not Found 找不到如何与 URI 相匹配的资源。\n\n•\t5XX: 服务器错误 \n\no\t500 Internal Server Error 最常见的服务器端错误。\n\no\t503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n\n#### HTML\n\n    语义化的理解\n\n•\t用正确的标签做正确的事情！\n\n•\thtml语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；\n\n•\t在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。\n\n•\t搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。\n\n•\t使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解\n\n    对浏览器内核的理解\n\n•\t主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎\n\n•\t渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核\n\n•\tJS引擎则：解析和执行javascript来实现网页的动态效果\n\n•\t最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎\n\n    HTML5的离线储存使用，工作原理\n\n•在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n\n•\t原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n\n•\t如何使用：\n\no\t页面头部像下面一样加入一个manifest的属性；\n\no\t在cache.manifest文件的编写离线存储的资源\n\no\t在离线状态时，操作window.applicationCache进行需求实现\nCACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html \n\n     描述一下 cookies，sessionStorage 和 localStorage 的区别\n\n•\tcookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）\n\n•\tcookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递\n\n•\tsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\n•\t存储大小：\n\no\tcookie数据大小不能超过4k\n\no\tsessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\n\n•\t有期时间：\n\no\tlocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据\n\no\tsessionStorage 数据在当前浏览器窗口关闭后自动删除\n\no\tcookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n    WEB标准以及W3C标准是什么\n\n •标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离\n\n    xhtml和html有什么区别\n\n•\t一个是功能上的差别\n\no\t主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页\n\n•\t另外是书写习惯的差别\n\no\tXHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素\n\n    Doctype作用，严格模式与混杂模式如何区分 它们有何意义 \n\n•\t页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载import只在IE5以上才能识别，而link是XHTML标签，无兼容问题link方式的样式的权重 高于@import的权重\n\n•\t<!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档\n\n•\t严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行\n\n•\t在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现\n\n\n    Canvas和SVG有什么区别\n\n•\tsvg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布\n\n•\tsvg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿\n\n    网页验证码是干嘛的，是为了解决什么安全问题\n\n•\t区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水\n\n•\t有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n\n    css3有哪些新特性\n\n•\t新增各种css选择器\n\n•\t圆角 border-radius \n\n•\t多列布局\n\n•\t阴影和反射\n\n•\t文字特效text-shadow \n\n•\t线性渐变\n\n\n    CSS3新增伪类有那些\n\n•\tp:first-of-type 选择属于其父元素的首个p元素的每个p 元素。\n\n•\tp:last-of-type 选择属于其父元素的最后 p 元素的每个p 元素。\n\n•\tp:only-of-type 选择属于其父元素唯一的 p元素的每个 p 元素。\n\n•\tp:only-child 选择属于其父元素的唯一子元素的每个 p 元素。\n\n•\tp:nth-child(2) 选择属于其父元素的第二个子元素的每个 p 元素。\n\n•\t:after 在元素之前添加内容,也可以用来做清除浮动。\n\n•\t:before 在元素之后添加内容\n\n•\t:enabled\n\n•\t:disabled 控制表单控件的禁用状态。\n\n•\t:checked 单选框或复选框被选中\n\n    异步加载JS的方式\n\n•\tdefer，只支持IE \n\n•\tasync：\n\n•\t创建script，插入到DOM中，加载完毕后callBack \n\n    常见web安全及防护原理\n\n•\tsql注入原理\n\no\t就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令\n\n•\t总的来说有以下几点\n\no\t永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双\"-\"进行转换等\n\no\t永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取\n\no\t永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接\n\no\t不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息\n\nXSS原理及防范\n\n•\tXss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点\nXSS防范方法\n\n•\t首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击\n\nXSS与CSRF有什么区别吗？\n\n•\tXSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤\n\n•\t登录受信任网站A，并在本地生成Cookie\n\n•\t在不登出A的情况下，访问危险网站B\n\nCSRF的防御\n\n•\t服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数\n\n•\t通过验证码的方法\n\n    设计模式\n\n•\t工厂模式：\n\no\t工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法\n\no\t主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字\n\n•\t构造函数模式\n\no\t使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于\n\no\t直接将属性和方法赋值给 this对象;\n\n\n    offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别\n\n•\toffsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同\n\n•\tclientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 \n\n•\tscrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 \n\n    说说你对promise的了解\n\n•\t依照 Promise/A+ 的定义，Promise 有四种状态：\n\no\tpending: 初始状态, 非 fulfilled 或 rejected.\n\no\tfulfilled: 成功的操作.\n\no\trejected: 失败的操作.\n\no\tsettled: Promise已被fulfilled或rejected，且不是pending\n\n•\t另外， fulfilled与 rejected一起合称 settled\n\n•\tPromise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算\n```\nvar promise = new Promise(function(resolve, reject) { \n\n             if (...) { \n\n                  // succeed              resolve(result); \n\n            } else {  \n\n                 // fails           reject(Error(errMessage)); \n            \n            }     }); \n\n```\n•\tPromise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：\npromise.then(onFulfilled, onRejected) \n\n•\t接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject \n\n    箭头函数与普通函数的区别\n\n•\t函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n\n•\t不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n\n•\t不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替\n\n•\t不可以使用yield命令，因此箭头函数不能用作Generator函数\n\n\n\n未完待续。。。。。"},{"title":"React封装倒计时","url":"/2018/04/27/React封装倒计时/","content":"\n``` \n //倒计时\n \nimport React from 'react';\n\nclass CountDown extends React.Component{\n    state ={\n        value:'cutdown'\n    }\n    componentDidMount () {\n        let {time=\"\",event={},leaveID=\"\",value} = this.props;\n        let {actions={}} = event;\n        var time_end,str_time;\n        time_end = new Date(time);//结束的时间\n        time_end = time_end.getTime();   //结束时间的时间戳\n        setInterval(show_time,1000)\n        var that = this;\n        function show_time() {\n            if (!time) { return; }\n                var time_now, time_distance;\n                var int_day, int_hour, int_minute, int_second;\n                time_now = new Date();   //开始时间\n                time_now = time_now.getTime();   //开始时间戳\n                time_distance = time_end - time_now;  // 结束时间戳-开始时间戳\n            if (time_distance > 0) {\n                int_day = Math.floor(time_distance / 86400000)\n                time_distance -= int_day * 86400000;\n                int_hour = Math.floor(time_distance / 3600000)\n                time_distance -= int_hour * 3600000;\n                int_minute = Math.floor(time_distance / 60000)\n                time_distance -= int_minute * 60000;\n                int_second = Math.floor(time_distance / 1000)\n                if (int_hour < 10)\n                    int_hour = \"0\" + int_hour;\n                if (int_minute < 10)\n                    int_minute = \"0\" + int_minute;\n                if (int_second < 10)\n                    int_second = \"0\" + int_second;\n                    str_time = int_hour + \"hr \" + int_minute + \"min \"+\" cutdown\";\n                    that.setState({value:str_time});\n                    value(str_time)\n                    if(int_hour==\"0\" &&  int_minute==\"0\"){\n                        actions.getWidth({ leave_id: leaveID, status_type: -1 })\n                    }\n            } else {\n                return;\n            }\n            \n        }\n    }\n    render () {\n        \n       return ( <span>{this.state.value}</span>)\n    }\n}\n\n\nexport default CountDown;\n\n```\n\n 调用 （前提是你已经在component里面创建文件夹并有返回内容）\n\n```\n import CountDown from 'component/CountDown';\n\n <CountDown time={data.close_time}></CountDown>\n```\n\n说明，\n倒计时如果你想使用setTimeout（）, 那么就需要在生命完成函数立即调用一次，和开始进入函数之前调用一次，总共两次。\n如果使用setInterval（），只需要调用一次即可。\n倒计时插件适用于移动和PC，具体样式没有太多说明，需要自己write。\n倒计时插件传入参数为结束时间，默认的开始时间为当前时间。\n倒计时插件返回值为 时 和 分，如需要天数和秒数自行添加，代码已经呈现。\n"},{"title":"Hello EveryBody","url":"/2018/04/27/hello-world/","content":"Welcome to my blog\n\n### Introduce oneself to\n``` \n    姓名： 齐贵奥 && Jaket\n\n    职业： web前端开发工程师\n\n    自我评价: 深度互联网从业人员，对互联网保持高度的敏感性和关注度，熟悉开发流程，有很强的 学习能力、需求分析、设计思路，有良好的语言沟通能力和良好的逻辑能力和团队协作能力。\n\n```\n### Technology stack\n- 熟练使用 HTML5/CSS3 及 LESS 和 SASS 等 css 预处理器，有 bootstrap 开发经验\n- 熟练掌握 JavaScript 语言和 JQuery 库, 熟练使用 Iscroll、Swiper 等插件\n- 熟悉 npm、yarn 包管理工具，掌握 git，sourceTree 等分工合作代码管理工具，同步开发\n- 熟练掌握微信小程序开发，根据官方API进项项目协作开发和管理\n- 熟练掌握 Webpack 等自动化构建工具，封装底层常用框架\n- 掌握 ajax、fetch、axios 等通信手段，掌握跨域手段及解决方案\n- 熟悉 Node.js，了解 ES6，熟练使用，vue，react 框架\n- 熟练运用 Hexo Element iview antd UI框架进行项目开发\n- 了解后端语言php，了解后端laravel框架，TP框架。\n\n\n\n### More info  \n  * [ 掘金--Jacket_7o ](https://juejin.im/user/59720b806fb9a06ba4746f3f/posts)\n  * [ github--qiguiao ](https://github.com/qiguiao)\n  * [ 个人博客--jaket ](https://qiguiao.github.io)\n\n"}]